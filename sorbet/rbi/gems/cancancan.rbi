# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/cancancan/all/cancancan.rbi
#
# cancancan-3.2.0

module CanCan
  def self.accessible_by_strategy; end
  def self.accessible_by_strategy=(value); end
  def self.default_accessible_by_strategy; end
  def self.valid_accessible_by_strategies; end
end
module CanCan::ParameterValidators
  def valid_attribute_param?(attribute); end
end
module CanCan::Ability
  def alternative_subjects(subject); end
  def attributes_for(action, subject); end
  def authorize!(action, subject, *args); end
  def can(action = nil, subject = nil, *attributes_and_conditions, &block); end
  def can?(action, subject, attribute = nil, *extra_args); end
  def cannot(action = nil, subject = nil, *attributes_and_conditions, &block); end
  def cannot?(*args); end
  def extract_rule_in_permissions(permissions_list, rule); end
  def extract_subjects(subject); end
  def has_block?(action, subject); end
  def has_raw_sql?(action, subject); end
  def merge(ability); end
  def model_adapter(model_class, action); end
  def permissions; end
  def unauthorized_message_keys(action, subject); end
  def validate_target(target); end
  include CanCan::Ability::Actions
  include CanCan::Ability::Rules
  include CanCan::Ability::StrongParameterSupport
  include CanCan::UnauthorizedMessageResolver
end
module CanCan::Ability::Rules
  def add_rule(rule); end
  def add_rule_to_index(rule, position); end
  def optimize_order!(rules); end
  def possible_relevant_rules(subject); end
  def relevant_rules(action, subject); end
  def relevant_rules_for_match(action, subject); end
  def relevant_rules_for_query(action, subject); end
  def rules; end
end
module CanCan::Ability::Actions
  def alias_action(*args); end
  def aliased_actions; end
  def aliases_for_action(action); end
  def clear_aliased_actions; end
  def default_alias_actions; end
  def expand_actions(actions); end
  def expanded_actions; end
end
module CanCan::UnauthorizedMessageResolver
  def translate_subject(subject); end
  def unauthorized_message(action, subject); end
end
module CanCan::Ability::StrongParameterSupport
  def get_attributes(rule, subject); end
  def permitted_attributes(action, subject); end
  def subject_class?(subject); end
end
module CanCan::ConditionsMatcher
  def call_block_with_all(action, subject, *extra_args); end
  def condition_match?(attribute, value); end
  def conditions_empty?; end
  def hash_condition_match?(attribute, value); end
  def matches_all_conditions?(adapter, conditions, subject); end
  def matches_block_conditions(subject, *extra_args); end
  def matches_conditions?(action, subject, attribute = nil, *extra_args); end
  def matches_conditions_hash?(subject, conditions = nil); end
  def matches_non_block_conditions(subject); end
  def model_adapter(subject); end
  def nested_subject_matches_conditions?(subject_hash); end
  def subject_class?(subject); end
end
class SubjectClassMatcher
  def self.matches_class_or_is_related(subject, sub); end
  def self.matches_subject_class?(subjects, subject); end
  def self.matching_class_check(subject, sub, has_subclasses); end
end
module CanCan::Relevant
  def matches_action?(action); end
  def matches_subject?(subject); end
  def matches_subject_class?(subject); end
  def relevant?(action, subject); end
end
class CanCan::Rule
  def actions; end
  def associations_hash(conditions = nil); end
  def attributes; end
  def attributes_from_conditions; end
  def base_behavior; end
  def block; end
  def can_rule?; end
  def cannot_catch_all?; end
  def catch_all?; end
  def condition_and_block_check(conditions, block, action, subject); end
  def conditions; end
  def conditions=(arg0); end
  def expanded_actions=(arg0); end
  def initialize(base_behavior, action, subject, *extra_args, &block); end
  def inspect; end
  def matches_action?(action); end
  def matches_attributes?(attribute); end
  def matches_subject?(subject); end
  def matches_subject_class?(subject); end
  def only_block?; end
  def only_raw_sql?; end
  def parse_attributes_from_extra_args(args); end
  def subjects; end
  def with_scope?; end
  def wrap(object); end
  include CanCan::ConditionsMatcher
  include CanCan::ParameterValidators
  include CanCan::Relevant
end
module CanCan::ControllerResourceFinder
  def find_by_dynamic_finder; end
  def find_by_find_by_finder; end
  def find_resource; end
  def find_resource_using_find_by; end
  def id_param; end
  def id_param_key; end
end
module CanCan::ControllerResourceNameFinder
  def name; end
  def name_from_controller; end
  def namespace; end
  def namespaced_name; end
end
module CanCan::ControllerResourceBuilder
  def assign_attributes(resource); end
  def build_resource; end
  def initial_attributes; end
end
module CanCan::ControllerResourceSanitizer
  def params_method; end
  def params_methods; end
  def sanitize_parameters; end
end
module CanCan::ControllerResourceLoader
  def authorization_action; end
  def extract_key(value); end
  def fetch_parent(name); end
  def load_collection; end
  def load_resource; end
  def load_resource_instance; end
  def new_actions; end
  def parent_authorization_action; end
  def parent_name; end
  def parent_resource; end
  def resource_base; end
  def resource_base_through; end
  def resource_base_through_parent_resource; end
  def resource_params; end
  def resource_params_by_key(key); end
  def resource_params_by_namespaced_name; end
  include CanCan::ControllerResourceBuilder
  include CanCan::ControllerResourceFinder
  include CanCan::ControllerResourceNameFinder
  include CanCan::ControllerResourceSanitizer
end
class CanCan::ControllerResource
  def action_exists_in?(options); end
  def adapter; end
  def authorize_resource; end
  def collection_actions; end
  def collection_instance; end
  def collection_instance=(instance); end
  def current_ability; end
  def initialize(controller, *args); end
  def instance_name; end
  def load_and_authorize_resource; end
  def load_collection?; end
  def load_instance?; end
  def member_action?; end
  def parameters_require_sanitizing?; end
  def parent?; end
  def resource_class; end
  def resource_class_with_parent; end
  def resource_instance; end
  def resource_instance=(instance); end
  def save_actions; end
  def self.add_before_action(controller_class, method, *args); end
  def self.before_callback_name(options); end
  def skip?(behavior); end
  include CanCan::ControllerResourceLoader
end
module CanCan::ControllerAdditions
  def authorize!(*args); end
  def can?(*args); end
  def cannot?(*args); end
  def current_ability; end
  def self.included(base); end
end
module CanCan::ControllerAdditions::ClassMethods
  def authorize_resource(*args); end
  def cancan_resource_class; end
  def cancan_skipper; end
  def check_authorization(options = nil); end
  def load_and_authorize_resource(*args); end
  def load_resource(*args); end
  def skip_authorization_check(*args); end
  def skip_authorize_resource(*args); end
  def skip_load_and_authorize_resource(*args); end
  def skip_load_resource(*args); end
end
class ActionController::Base < ActionController::Metal
  def _cancan_skipper; end
  def _cancan_skipper=(val); end
  def _cancan_skipper?; end
  def self._cancan_skipper; end
  def self._cancan_skipper=(val); end
  def self._cancan_skipper?; end
  extend CanCan::ControllerAdditions::ClassMethods
  include CanCan::ControllerAdditions
end
class ActionController::API < ActionController::Metal
  def _cancan_skipper; end
  def _cancan_skipper=(val); end
  def _cancan_skipper?; end
  def self._cancan_skipper; end
  def self._cancan_skipper=(val); end
  def self._cancan_skipper?; end
  extend CanCan::ControllerAdditions::ClassMethods
  include CanCan::ControllerAdditions
end
module CanCan::ModelAdditions
  def self.included(base); end
end
module CanCan::ModelAdditions::ClassMethods
  def accessible_by(ability, action = nil); end
end
class CanCan::Error < StandardError
end
class CanCan::NotImplemented < CanCan::Error
end
class CanCan::ImplementationRemoved < CanCan::Error
end
class CanCan::AuthorizationNotPerformed < CanCan::Error
end
class CanCan::BlockAndConditionsError < CanCan::Error
end
class CanCan::AttributeArgumentError < CanCan::Error
end
class CanCan::WrongAssociationName < CanCan::Error
end
class CanCan::AccessDenied < CanCan::Error
  def action; end
  def conditions; end
  def default_message=(arg0); end
  def initialize(message = nil, action = nil, subject = nil, conditions = nil); end
  def inspect; end
  def subject; end
  def to_s; end
end
module CanCan::ModelAdapters
end
class CanCan::ModelAdapters::AbstractAdapter
  def database_records; end
  def initialize(model_class, rules); end
  def self.adapter_class(model_class); end
  def self.find(model_class, id); end
  def self.for_class?(_member_class); end
  def self.inherited(subclass); end
  def self.matches_condition?(_subject, _name, _value); end
  def self.matches_conditions_hash?(_subject, _conditions); end
  def self.override_condition_matching?(_subject, _name, _value); end
  def self.override_conditions_hash_matching?(_subject, _conditions); end
end
class CanCan::ModelAdapters::DefaultAdapter < CanCan::ModelAdapters::AbstractAdapter
end
class CanCan::RulesCompressor
  def compress(array); end
  def initial_rules; end
  def initialize(rules); end
  def rules_collapsed; end
end
class CanCan::ModelAdapters::ConditionsExtractor
  def add_to_cache(table_alias, relation_name, path_to_key); end
  def alredy_used?(table_alias, relation_name, path_to_key); end
  def calculate_nested(model_class, result_hash, relation_name, value, path_to_key); end
  def calculate_result_hash(key, model_class, path_to_key, result_hash, value); end
  def generate_table_alias(model_class, relation_name, path_to_key); end
  def initialize(model_class); end
  def tableize_conditions(conditions, model_class = nil, path_to_key = nil); end
end
class CanCan::ModelAdapters::ConditionsNormalizer
  def self.calculate_result_hash(model_class, key, value); end
  def self.normalizable_association?(reflection); end
  def self.normalize(model_class, rules); end
  def self.normalize_conditions(model_class, conditions); end
end
class CanCan::ModelAdapters::StiNormalizer
  def self.build_rule_for_subclass(rule, subject); end
  def self.normalize(rules); end
end
class CanCan::ModelAdapters::ActiveRecordAdapter < CanCan::ModelAdapters::AbstractAdapter
  def build_relation(*where_conditions); end
  def conditions; end
  def database_records; end
  def deep_clean(joins_hash); end
  def deep_merge(base_hash, added_hash); end
  def extract_multiple_conditions(conditions_extractor, rules); end
  def false_sql; end
  def initialize(model_class, rules); end
  def joins; end
  def merge_conditions(sql, conditions_hash, behavior); end
  def merge_non_empty_conditions(behavior, conditions_hash, sql); end
  def override_scope; end
  def raise_override_scope_error; end
  def sanitize_sql(conditions); end
  def self.version_greater_or_equal?(version); end
  def self.version_lower?(version); end
  def true_sql; end
end
class CanCan::ModelAdapters::ActiveRecord4Adapter < CanCan::ModelAdapters::ActiveRecordAdapter
  def build_joins_relation(relation, *_where_conditions); end
  def sanitize_sql(conditions); end
  def sanitize_sql_activerecord4(conditions); end
  def self.for_class?(model_class); end
  def self.matches_condition?(subject, name, value); end
  def self.override_condition_matching?(subject, name, _value); end
end
class CanCan::ModelAdapters::ActiveRecord5Adapter < CanCan::ModelAdapters::ActiveRecord4Adapter
  def build_joins_relation(relation, *where_conditions); end
  def sanitize_sql(conditions); end
  def sanitize_sql_activerecord5(conditions); end
  def self.for_class?(model_class); end
  def self.matches_condition?(subject, name, value); end
  def visit_nodes(node); end
end
